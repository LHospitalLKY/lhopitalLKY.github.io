{"meta":{"title":null,"subtitle":"","description":"","author":"Lei Kaiyu","url":"http://yoursite.com","root":"/lhopitalLKY.github.io/"},"pages":[],"posts":[{"title":"线段直线交点实验","slug":"线段直线交点实验","date":"2020-05-26T08:31:58.000Z","updated":"2020-05-26T08:31:58.000Z","comments":true,"path":"2020/05/26/线段直线交点实验/","link":"","permalink":"http://yoursite.com/2020/05/26/%E7%BA%BF%E6%AE%B5%E7%9B%B4%E7%BA%BF%E4%BA%A4%E7%82%B9%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"[toc] 1. 图像直线交点计算1.1 两条直线的交点在平面中，两条不平行的直线必然存在一个交点。设两条直线的方程分别为$a_1 x + b_1 y + c_1 = 0$与$a_2 x + b_2 y + c_2 = 0$，根据解析几何理论，两条直线的交点通过求解以下一元二次方程组得到：$$\\begin{cases} a_1 x + b_1 y + c_1 = 0 \\ a_1 x + b_2 y + c_2 = 0\\end{cases}$$ 根据以上方法，写出了给定两条直线的端点，计算它们交点的程序： 1234567891011121314cv::Point2f getCrossPoint(const cv::Vec4f &amp;line_0, const cv::Vec4f &amp;line_1) &#123; double ka, kb; ka = (double)(line_0(3) - line_0(1)) / (double)(line_0(2) - line_0(0) + 1e-5); kb = (double)(line_1(3) - line_1(1)) / (double)(line_1(2) - line_1(0) + 1e-5); cv::Point2f crossPoint; if(std::fabs(ka - kb) &lt; 0.001) &#123; return cv::Point2f(99999, 99999); &#125; crossPoint.x = (ka * line_0(0) - line_0(1) - kb * line_1(0) + line_1(1)) / (ka - kb); crossPoint.y = (ka*kb*(line_0(0) - line_1(0)) + ka * line_1(1) - kb*line_0(1)) / (ka - kb); return crossPoint;&#125; 其中： 程序中涉及到求斜率的问题，在遇到$y = c$这类直线时，理论上斜率为0. 会出现斜率无穷大的情况. 为了解决这种问题，在求斜率时，分母会加上$10^{-5}$，以求出近似的数值解. 在实际的线特征中，往往会提取出两条平行线段(如桌子的同一条边的上下边缘)，此时理论上不存在交点. 为了解决这个问题，当斜率之间的差小于0.001时，认为两条直线是平行的，返回一个很大的二维向量(99999, 99999)，以便后续过滤. 在提取出图像中的线特征之后，计算这些直线的交点，得到如下所示的结果： 显然，上述结果得到的交点没有任何意义，需要增加过滤条件。显然，有用的交点对应这现实中的一些客观实体，如桌角、电脑屏幕的四个角等。这些位置的特征如图所示： 这些位置通常在两条线特征的共同交点附近。因此，根据这个特征来进行筛选. 给定两个cv::KeyLine类型的输入，根据一下流程来实现筛选： 123456789101112131415161718192021@startuml(*) --&gt; &quot;输入KeyLines line_1, line_2&quot;--&gt; &quot;计算line_1与line_2的直线角度angle_1与angle_2&quot;if &quot;angle_1与angle_2之间的角度差小于π&#x2F;24&quot; --&gt; [true] &quot;计算line_1与line_2所代表的直线的交点P&quot; --&gt; &quot;计算P与line_1端点、line_2端点之间的距离&quot; --&gt; &quot;选取P与四个端点之间的最小距离dist_min&quot; if &quot;dist_min &lt;&#x3D; MIN_DIST_THRESHOLD&quot; --&gt; [true] &quot;返回交点&quot; --&gt; [Ending process] (*) else -left-&gt; [false] &quot;返回异常点&quot; endif --&gt; [Ending process] (*)else --&gt; [false] &quot;返回异常点&quot; --&gt; [Ending process] (*)endif@enduml","categories":[],"tags":[{"name":"SLAM VINS 实验笔记","slug":"SLAM-VINS-实验笔记","permalink":"http://yoursite.com/tags/SLAM-VINS-%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"}]},{"title":"Plucker坐标直线表示的初始化实验","slug":"Plucker坐标直线表示的初始化实验","date":"2020-05-20T08:30:02.000Z","updated":"2020-05-20T08:30:02.000Z","comments":true,"path":"2020/05/20/Plucker坐标直线表示的初始化实验/","link":"","permalink":"http://yoursite.com/2020/05/20/Plucker%E5%9D%90%E6%A0%87%E7%9B%B4%E7%BA%BF%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"[toc] 在初始化阶段，需要得到直线端点的3D坐标以通过PNP来初始化位姿，计算出直线端点的3D坐标后进行可视化，得到的是如下的结果： 5.21遇到的问题： g2o_type.h里原本的bundle adjustment函数编译失败 可视化部分比前一天要好，但是仍然会出现问题. 经过debug发现，是Lc*pi_s或Lc*pi_e的时候，直线的第四维比较小，导致中间某个数值很大，很长很长的直线. 究其原因，还是对于Plucker Coordinate不太熟，要去PL VIO里进行更细致的分析 Bundle Adjustment应该写的是错的，再调整调整","categories":[],"tags":[{"name":"SLAM VINS 实验笔记","slug":"SLAM-VINS-实验笔记","permalink":"http://yoursite.com/tags/SLAM-VINS-%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"}]},{"title":"基于Plucker表示的线特征三角化","slug":"基于Plucker表示的线特征三角化","date":"2020-05-18T10:40:58.000Z","updated":"2020-05-18T10:40:58.000Z","comments":true,"path":"2020/05/18/基于Plucker表示的线特征三角化/","link":"","permalink":"http://yoursite.com/2020/05/18/%E5%9F%BA%E4%BA%8EPlucker%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%BA%BF%E7%89%B9%E5%BE%81%E4%B8%89%E8%A7%92%E5%8C%96/","excerpt":"","text":"[TOC] 直线的普吕克坐标(Plucker Coordinate)表示普吕克坐标于19世纪被Julius Plucker提出。在几何中，常常将直线转化到普吕克坐标下来直线。在普吕克坐标下，直线表示为齐次六维向量。 如图所示： 设空间直线为$l$，在直线上两个不同点$X, Y$，记：$$\\bm{d} = Y - X$$$$\\bm{m} = X \\times Y$$则直线$l$的普吕克表示为：$$L = \\begin{bmatrix} \\bm{d} \\ \\bm{m} \\end{bmatrix} \\in \\mathbb{P}^5 \\subsetneqq \\mathbb{R}^6$$ 我们可以看出，向量$\\bm{d}$为直线的方向向量，向量$\\bm{m}$平面$XCY$的法向量。因此，普吕克坐标表示的直线隐含了约束条件：$$\\bm{d}^T\\bm{m} = 0$$","categories":[],"tags":[{"name":"SLAM VINS 实验笔记","slug":"SLAM-VINS-实验笔记","permalink":"http://yoursite.com/tags/SLAM-VINS-%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"}]},{"title":"VINS-Mono-初始化","slug":"VINS-Mono-初始化","date":"2020-05-15T09:05:33.000Z","updated":"2020-05-15T09:05:33.000Z","comments":true,"path":"2020/05/15/VINS-Mono-初始化/","link":"","permalink":"http://yoursite.com/2020/05/15/VINS-Mono-%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"数据结构1234567891011// 用于SFM初始化的Feature结构体struct SFMFeature&#123; bool state; // 用于判断当前特征是否被三角化过 int id; // 当前Feature的id // 当前Feature的观测值 // pair中的int表示在int代表的frame中，该特征点被观测到了 vector&lt;pair&lt;int,Vector2d&gt;&gt; observation; double position[3]; // 当前特征在空间中的位置 double depth; // 深度(VINS的点特征用depth表示)&#125;; 流程","categories":[],"tags":[{"name":"SLAM VINS","slug":"SLAM-VINS","permalink":"http://yoursite.com/tags/SLAM-VINS/"}]}],"categories":[],"tags":[{"name":"SLAM VINS 实验笔记","slug":"SLAM-VINS-实验笔记","permalink":"http://yoursite.com/tags/SLAM-VINS-%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"},{"name":"SLAM VINS","slug":"SLAM-VINS","permalink":"http://yoursite.com/tags/SLAM-VINS/"}]}